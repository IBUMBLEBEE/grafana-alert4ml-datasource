use std::f64;

/// 计算四分位距（IQR）
///
/// # 参数
///
/// * `data` - 输入数据切片
/// * `rng` - 百分位数范围，默认为 (25.0, 75.0)
/// * `scale` - 缩放因子，默认为 1.0
/// * `interpolation` - 插值方法，默认为 "linear"
///
/// # 返回
///
/// 返回 IQR 值。如果数据为空，返回 None
pub fn iqr(
    data: &[f64],
    rng: Option<(f64, f64)>,
    scale: Option<f64>,
    interpolation: Option<&str>,
) -> Option<f64> {
    if data.is_empty() {
        return None;
    }

    let (q1, q3) = rng.unwrap_or((25.0, 75.0));
    let scale = scale.unwrap_or(1.0);
    let interpolation = interpolation.unwrap_or("linear");

    // 计算百分位数
    let p1 = percentile(data, q1, interpolation);
    let p2 = percentile(data, q3, interpolation);

    // 计算 IQR
    let iqr = (p2 - p1) / scale;

    Some(iqr)
}

/// 使用 IQR 进行动态阈值异常检测
///
/// # 参数
///
/// * `data` - 输入时间序列数据
/// * `window_size` - 移动窗口大小
/// * `threshold` - IQR 乘数阈值，默认为 1.5
///
/// # 返回
///
/// 返回异常检测结果，1 表示异常点，0 表示正常点
pub fn iqr_anomaly_detection(data: &[f64], window_size: usize, upper_percentile: Option<f64>, lower_percentile: Option<f64>, threshold: Option<f64>) -> Vec<f64> {
    if data.is_empty() || window_size == 0 {
        return vec![];
    }

    let upper_percentile = upper_percentile.unwrap_or(75.0);
    let lower_percentile = lower_percentile.unwrap_or(25.0);
    let threshold = threshold.unwrap_or(2.0);
    let mut anomalies = vec![0.0; data.len()];

    // 对于每个点，使用其前 window_size 个点计算 IQR
    for i in window_size..data.len() {
        let window = &data[i - window_size..i];
        if let Some(iqr_value) = iqr(window, None, None, None) {
            let q1 = percentile(window, lower_percentile, "linear");
            let q3 = percentile(window, upper_percentile, "linear");
            
            // 计算上下界
            let lower_bound = q1 - threshold * iqr_value;
            let upper_bound = q3 + threshold * iqr_value;
            
            // 判断当前点是否异常
            let is_anomaly = data[i] < lower_bound || data[i] > upper_bound;
            anomalies[i] = if is_anomaly { 1.0 } else { 0.0 };
        }
    }

    anomalies
}

/// 计算百分位数
fn percentile(data: &[f64], p: f64, interpolation: &str) -> f64 {
    if data.is_empty() {
        return f64::NAN;
    }

    let mut sorted = data.to_vec();
    sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());

    let n = sorted.len();
    let h = (n - 1) as f64 * p / 100.0;
    let i = h.floor() as usize;
    let fraction = h - i as f64;

    match interpolation {
        "linear" => {
            if i + 1 >= n {
                sorted[i]
            } else {
                sorted[i] + fraction * (sorted[i + 1] - sorted[i])
            }
        }
        "lower" => sorted[i],
        "higher" => {
            if i + 1 >= n {
                sorted[i]
            } else {
                sorted[i + 1]
            }
        }
        "nearest" => {
            if fraction < 0.5 {
                sorted[i]
            } else if i + 1 >= n {
                sorted[i]
            } else {
                sorted[i + 1]
            }
        }
        "midpoint" => {
            if i + 1 >= n {
                sorted[i]
            } else {
                (sorted[i] + sorted[i + 1]) / 2.0
            }
        }
        _ => sorted[i],
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_iqr() {
        let data = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
        let result = iqr(&data, None, None, None).unwrap();
        assert!((result - 4.0).abs() < 1e-10);
    }

    #[test]
    fn test_iqr_empty() {
        let data: Vec<f64> = vec![];
        let result = iqr(&data, None, None, None);
        assert!(result.is_none());
    }

    #[test]
    fn test_iqr_custom_range() {
        let data = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
        let result = iqr(&data, Some((10.0, 90.0)), None, None).unwrap();
        assert!((result - 6.4).abs() < 1e-10);
    }

    #[test]
    fn test_iqr_real_data() {
        let data = vec![
            0.46002850485237834, 0.4576352533053146, 0.4542500598806185, 0.4533267818329806,
            0.4526311802637061, 0.45123549344891845, 0.44650462593936824, 0.44505434951895895,
            0.4443938023927284, 0.44325917237782375, 0.4427440620530148, 0.4441718277772019,
            0.44580187930605103, 0.4541452536930968, 0.4754025599017207, 0.486768420462442,
            0.49037981248157453, 0.49496777187813623, 0.4928683782586715, 0.4940997734133051,
        ];
        let result = iqr(&data, None, None, None).unwrap();
        assert!(result > 0.0);
    }

    #[test]
    fn test_iqr_anomaly_detection() {
        // 创建一个包含异常点的测试数据
        let mut data = vec![0.46002850485237834, 0.4576352533053146, 0.4542500598806185, 0.4533267818329806, 0.4526311802637061, 0.45123549344891845, 0.44650462593936824, 0.44505434951895895, 0.4443938023927284, 0.44325917237782375, 0.4427440620530148, 0.4441718277772019, 0.44580187930605103, 0.4541452536930968, 0.4754025599017207, 0.486768420462442, 0.49037981248157453, 0.49496777187813623, 0.4928683782586715, 0.4940997734133051, 0.4894023914971617, 0.4691138925238345, 0.4550807291759916, 0.4370053081068987, 0.42659046604333145, 0.4230625476271172, 0.42275748265374596, 0.42103484572062844, 0.42418136495947567, 0.4201300185120702, 0.4177626681586741, 0.41803506460180406, 0.415827445041435, 0.41524067127177744, 0.41870666378874355, 0.41519931785376707, 0.4174357397432302, 0.4286829941673443, 0.44792775483868746, 0.455562949750598, 0.45556737365808125, 0.46106071313166835, 0.46614028757975884, 0.46648961758727364, 0.4573294348384323, 0.4493298310151603, 0.4345084457694815, 0.4199320432528441, 0.4138045725673647, 0.40847956455081164, 0.4081581272814859, 0.41312482187466987, 0.41331519263736216, 0.41157282643136067, 0.4106115566796198, 0.4187949661584493, 0.42254013360389625, 0.42954157541654014, 0.43387233652529716, 0.43286957415497307, 0.42034768022901065, 0.41936660212873406, 0.42877088321061935, 0.4400207551243875, 0.43530142238031994, 0.43633504367638865, 0.44140045100393455, 0.44042410886040734, 0.4369954628624637, 0.43129135091434817, 0.43304173639384347, 0.4250811727904415, 0.4268076168873296, 0.4294413883900979, 0.4333014271282628, 0.43724604904635744, 0.4389973302191017, 0.43820524048954684, 0.43778604766612217, 0.44106947088622644, 0.44529701416237505, 0.4519483890373588, 0.4506295220123975, 0.44996836599105283, 0.4493475142472534, 0.439659075728553, 0.43555077952391624, 0.424137964746249, 0.41898962914376453, 0.41800613309293644, 0.41668488947760124, 0.4155759804100715, 0.43331496818290866, 0.45795869910635045, 0.4647369051024681, 0.45064939326945513, 0.451246809196935, 0.46142810981730387, 0.46615154783534707, 0.47212234851216905, 0.47362833700102797, 0.4728177097001258, 0.4709686290708062, 0.4723900138767592, 0.47020030764053466, 0.47064830344740544, 0.4748070080768707, 0.475558689852563, 0.47086199696186454, 0.46305673749247606, 0.45326550003421057, 0.4343782247541333, 0.4213277387611639, 0.410240702706125, 0.4092537664315118, 0.4074782310599027, 0.43641762397118705, 0.46904919546449203, 0.4760924321255192, 0.46243717241273863, 0.4488802372687226, 0.4447457143754277, 0.43495725983669303, 0.4207942293949999, 0.4162389611511382, 0.4143393948572579, 0.4179044333487664, 0.416020164930143, 0.41564429781885487, 0.419074521798637, 0.4193881481463829, 0.4259432821049251, 0.43123777984189854, 0.420005594119897, 0.4201576183356171, 0.41955701928908534, 0.4179684369197562, 0.4185916518164833, 0.41889956435196446, 0.418736869520768, 0.4193281211173916, 0.4187664644200764, 0.450159907240459, 0.4772461980063912, 0.49816194321180385, 0.5144047850272743, 0.5203968615721336, 0.5003259276616078, 0.5046721807915789, 0.5057395327376712, 0.5024351322546946, 0.49609523740201095, 0.49140408145556996, 0.489736802390985, 0.5053624664772685, 0.5058656825714477, 0.49727746296787034, 0.47455601957700283, 0.4741823358547793, 0.4660812410072631, 0.4578776477645792, 0.44985109000058277, 0.45478963213817614, 0.45514456884393295, 0.4630835187299597, 0.4935290178851892, 0.536734727459987, 0.5764817588886727, 0.6050084719466015, 0.6238613046969367, 0.6216376273176505, 0.6088621439801024, 0.6097430369422309, 0.6107908544617245, 0.6067193727361956, 0.5998722876771899, 0.5941874794108384, 0.5999415489237527, 0.6139411209268762, 0.6244835377268196, 0.6005872244165366, 0.5805889650018184, 0.5522041706570474, 0.5247558769760265, 0.4982136895249565, 0.4861926377461543, 0.4865433505966213, 0.49043282973894753, 0.5037011585080113, 0.5291529627408468, 0.5979265509203348, 0.6284522801101419, 0.6333696900170547, 0.6374426727798985, 0.6331465259556591, 0.612268658004085, 0.6001624740708247, 0.572073571937422, 0.5402030706552293, 0.5036638816728899, 0.49300292010027297, 0.4998634740163454, 0.5172383480084867, 0.514329961753366, 0.4929963589545091, 0.49801161895935475, 0.5053524104665839, 0.5140389621692282, 0.5133864419771136, 0.5153538205955391, 0.5202447236333875, 0.5177466246689626, 0.5184744115405634, 0.5187365643545495, 0.5254430549510519, 0.5233396016305998, 0.5036878650714455, 0.4978429736305526, 0.5039565931100863, 0.5019382532003229, 0.49779896912642113, 0.49847487288454845, 0.49758725290853506];
        data[5] = 5.0; // 添加一个明显的异常点
        
        let window_size = 20; // 增加窗口大小
        let threshold = 3.0; // 调整阈值
        let anomalies = iqr_anomaly_detection(&data, window_size, Some(90.0), Some(10.0), Some(threshold));
        
        // 打印异常点数量
        let anomaly_count = anomalies.iter().filter(|&&x| x == 1.0).count();
        println!("Total anomalies detected: {}", anomaly_count);
        
        // 打印异常点的位置和值
        for (i, &is_anomaly) in anomalies.iter().enumerate() {
            if is_anomaly == 1.0 {
                println!("Anomaly at index {}: value={}", i, data[i]);
            }
        }
    }
}
